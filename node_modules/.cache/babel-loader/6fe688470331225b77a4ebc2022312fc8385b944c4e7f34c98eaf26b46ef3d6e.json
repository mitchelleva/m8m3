{"ast":null,"code":"export const SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nexport const ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nexport function getPlacementData({\n  anchorRect: c,\n  popperSize: s,\n  arrowSize: f,\n  arrowOffset: l = 0,\n  side: d,\n  sideOffset: h = 0,\n  align: x,\n  alignOffset: g = 0,\n  shouldAvoidCollisions: u = !0,\n  collisionBoundariesRect: w,\n  collisionTolerance: m = 0\n}) {\n  if (!c || !s || !w) return {\n    popperStyles: r,\n    arrowStyles: n\n  };\n  const y = function (e, o, r = 0, n = 0, i) {\n      const c = i ? i.height : 0,\n        a = t(o, e, \"x\"),\n        p = t(o, e, \"y\"),\n        s = p.before - r - c,\n        f = p.after + r + c,\n        l = a.before - r - c,\n        d = a.after + r + c;\n      return {\n        top: {\n          start: {\n            x: a.start + n,\n            y: s\n          },\n          center: {\n            x: a.center,\n            y: s\n          },\n          end: {\n            x: a.end - n,\n            y: s\n          }\n        },\n        right: {\n          start: {\n            x: d,\n            y: p.start + n\n          },\n          center: {\n            x: d,\n            y: p.center\n          },\n          end: {\n            x: d,\n            y: p.end - n\n          }\n        },\n        bottom: {\n          start: {\n            x: a.start + n,\n            y: f\n          },\n          center: {\n            x: a.center,\n            y: f\n          },\n          end: {\n            x: a.end - n,\n            y: f\n          }\n        },\n        left: {\n          start: {\n            x: l,\n            y: p.start + n\n          },\n          center: {\n            x: l,\n            y: p.center\n          },\n          end: {\n            x: l,\n            y: p.end - n\n          }\n        }\n      };\n    }(s, c, h, g, f),\n    b = y[d][x];\n  if (!1 === u) {\n    const t = e(b);\n    let r = n;\n    f && (r = i({\n      popperSize: s,\n      arrowSize: f,\n      arrowOffset: l,\n      side: d,\n      align: x\n    }));\n    return {\n      popperStyles: {\n        ...t,\n        \"--radix-popper-transform-origin\": o(s, d, x, l, f)\n      },\n      arrowStyles: r,\n      placedSide: d,\n      placedAlign: x\n    };\n  }\n  const S = DOMRect.fromRect({\n      ...s,\n      ...b\n    }),\n    O = (z = w, R = m, DOMRect.fromRect({\n      width: z.width - 2 * R,\n      height: z.height - 2 * R,\n      x: z.left + R,\n      y: z.top + R\n    }));\n  var z, R;\n  const M = p(S, O),\n    D = y[a(d)][x],\n    A = function (t, e, o) {\n      const r = a(t);\n      return e[t] && !o[r] ? r : t;\n    }(d, M, p(DOMRect.fromRect({\n      ...s,\n      ...D\n    }), O)),\n    I = function (t, e, o, r, n) {\n      const i = \"top\" === o || \"bottom\" === o,\n        c = i ? \"left\" : \"top\",\n        a = i ? \"right\" : \"bottom\",\n        p = i ? \"width\" : \"height\",\n        s = e[p] > t[p];\n      if ((\"start\" === r || \"center\" === r) && (n[c] && s || n[a] && !s)) return \"end\";\n      if ((\"end\" === r || \"center\" === r) && (n[a] && s || n[c] && !s)) return \"start\";\n      return r;\n    }(s, c, d, x, M),\n    v = e(y[A][I]);\n  let C = n;\n  f && (C = i({\n    popperSize: s,\n    arrowSize: f,\n    arrowOffset: l,\n    side: A,\n    align: I\n  }));\n  return {\n    popperStyles: {\n      ...v,\n      \"--radix-popper-transform-origin\": o(s, A, I, l, f)\n    },\n    arrowStyles: C,\n    placedSide: A,\n    placedAlign: I\n  };\n}\nfunction t(t, e, o) {\n  const r = t[\"x\" === o ? \"left\" : \"top\"],\n    n = \"x\" === o ? \"width\" : \"height\",\n    i = t[n],\n    c = e[n];\n  return {\n    before: r - c,\n    start: r,\n    center: r + (i - c) / 2,\n    end: r + i - c,\n    after: r + i\n  };\n}\nfunction e(t) {\n  const e = Math.round(t.x + window.scrollX),\n    o = Math.round(t.y + window.scrollY);\n  return {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    minWidth: \"max-content\",\n    willChange: \"transform\",\n    transform: \"translate3d(\".concat(e, \"px, \").concat(o, \"px, 0)\")\n  };\n}\nfunction o(t, e, o, r, n) {\n  const i = \"top\" === e || \"bottom\" === e,\n    c = n ? n.width : 0,\n    a = n ? n.height : 0,\n    p = c / 2 + r;\n  let s = \"\",\n    f = \"\";\n  return i ? (s = {\n    start: \"\".concat(p, \"px\"),\n    center: \"center\",\n    end: \"\".concat(t.width - p, \"px\")\n  }[o], f = \"\".concat(\"top\" === e ? t.height + a : -a, \"px\")) : (s = \"\".concat(\"left\" === e ? t.width + a : -a, \"px\"), f = {\n    start: \"\".concat(p, \"px\"),\n    center: \"center\",\n    end: \"\".concat(t.height - p, \"px\")\n  }[o]), \"\".concat(s, \" \").concat(f);\n}\nconst r = {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    opacity: 0,\n    pointerEvents: \"none\"\n  },\n  n = {\n    position: \"absolute\",\n    opacity: 0\n  };\nfunction i({\n  popperSize: t,\n  arrowSize: e,\n  arrowOffset: o,\n  side: r,\n  align: n\n}) {\n  const i = (t.width - e.width) / 2,\n    a = (t.height - e.width) / 2,\n    p = {\n      top: 0,\n      right: 90,\n      bottom: 180,\n      left: -90\n    }[r],\n    s = Math.max(e.width, e.height),\n    f = {\n      width: \"\".concat(s, \"px\"),\n      height: \"\".concat(s, \"px\"),\n      transform: \"rotate(\".concat(p, \"deg)\"),\n      willChange: \"transform\",\n      position: \"absolute\",\n      [r]: \"100%\",\n      direction: c(r, n)\n    };\n  return \"top\" !== r && \"bottom\" !== r || (\"start\" === n && (f.left = \"\".concat(o, \"px\")), \"center\" === n && (f.left = \"\".concat(i, \"px\")), \"end\" === n && (f.right = \"\".concat(o, \"px\"))), \"left\" !== r && \"right\" !== r || (\"start\" === n && (f.top = \"\".concat(o, \"px\")), \"center\" === n && (f.top = \"\".concat(a, \"px\")), \"end\" === n && (f.bottom = \"\".concat(o, \"px\"))), f;\n}\nfunction c(t, e) {\n  return (\"top\" !== t && \"right\" !== t || \"end\" !== e) && (\"bottom\" !== t && \"left\" !== t || \"end\" === e) ? \"ltr\" : \"rtl\";\n}\nfunction a(t) {\n  return {\n    top: \"bottom\",\n    right: \"left\",\n    bottom: \"top\",\n    left: \"right\"\n  }[t];\n}\nfunction p(t, e) {\n  return {\n    top: t.top < e.top,\n    right: t.right > e.right,\n    bottom: t.bottom > e.bottom,\n    left: t.left < e.left\n  };\n}","map":{"version":3,"names":["SIDE_OPTIONS","ALIGN_OPTIONS","getPlacementData","anchorRect","c","popperSize","s","arrowSize","f","arrowOffset","l","side","d","sideOffset","h","align","x","alignOffset","g","shouldAvoidCollisions","u","collisionBoundariesRect","w","collisionTolerance","m","popperStyles","r","arrowStyles","n","y","e","o","i","height","a","t","p","before","after","top","start","center","end","right","bottom","left","b","placedSide","placedAlign","S","DOMRect","fromRect","O","z","R","width","M","D","A","I","v","C","Math","round","window","scrollX","scrollY","position","minWidth","willChange","transform","concat","opacity","pointerEvents","max","direction"],"sources":["/Users/mitchelleva/projects/me8porty/m8magic/node_modules/@radix-ui/popper/dist/packages/core/popper/src/popper.ts"],"sourcesContent":["import * as CSS from 'csstype';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Axis = 'x' | 'y';\ntype Side = typeof SIDE_OPTIONS[number];\ntype Align = typeof ALIGN_OPTIONS[number];\ntype Point = { x: number; y: number };\ntype Size = { width: number; height: number };\n\ntype GetPlacementDataOptions = {\n  /** The rect of the anchor we are placing around */\n  anchorRect?: ClientRect;\n  /** The size of the popper to place */\n  popperSize?: Size;\n  /** An optional arrow size */\n  arrowSize?: Size;\n  /** An optional arrow offset (along the side, default: 0) */\n  arrowOffset?: number;\n  /** The desired side */\n  side: Side;\n  /** An optional side offset (distance from the side, default: 0)  */\n  sideOffset?: number;\n  /** The desired alignment */\n  align: Align;\n  /** An optional alignment offset (distance along the side, default: 0) */\n  alignOffset?: number;\n  /** An option to turn on/off the collision handling (default: true) */\n  shouldAvoidCollisions?: boolean;\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect?: ClientRect;\n  /** The tolerance used for collisions, ie. if we want them to trigger a bit earlier (default: 0) */\n  collisionTolerance?: number;\n};\n\ntype PlacementData = {\n  popperStyles: CSS.Properties;\n  arrowStyles: CSS.Properties;\n  placedSide?: Side;\n  placedAlign?: Align;\n};\n\n/**\n * Given all the information necessary to compute it,\n * this function calculates all the necessary placement data.\n *\n * It will return:\n *\n * - the styles to apply to the popper (including a custom property that is useful to set the transform origin in the right place)\n * - the styles to apply to the arrow\n * - the placed side (because it might have changed because of collisions)\n * - the placed align (because it might have changed because of collisions)\n */\nfunction getPlacementData({\n  anchorRect,\n  popperSize,\n  arrowSize,\n  arrowOffset = 0,\n  side,\n  sideOffset = 0,\n  align,\n  alignOffset = 0,\n  shouldAvoidCollisions = true,\n  collisionBoundariesRect,\n  collisionTolerance = 0,\n}: GetPlacementDataOptions): PlacementData {\n  // if we're not ready to do all the measurements yet,\n  // we return some good default styles\n  if (!anchorRect || !popperSize || !collisionBoundariesRect) {\n    return {\n      popperStyles: UNMEASURED_POPPER_STYLES,\n      arrowStyles: UNMEASURED_ARROW_STYLES,\n    };\n  }\n\n  // pre-compute points for all potential placements\n  const allPlacementPoints = getAllPlacementPoints(\n    popperSize,\n    anchorRect,\n    sideOffset,\n    alignOffset,\n    arrowSize\n  );\n\n  // get point based on side / align\n  const popperPoint = allPlacementPoints[side][align];\n\n  // if we don't need to avoid collisions, we can stop here\n  if (shouldAvoidCollisions === false) {\n    const popperStyles = getPlacementStylesForPoint(popperPoint);\n\n    let arrowStyles = UNMEASURED_ARROW_STYLES;\n    if (arrowSize) {\n      arrowStyles = getPopperArrowStyles({ popperSize, arrowSize, arrowOffset, side, align });\n    }\n\n    const transformOrigin = getTransformOrigin(popperSize, side, align, arrowOffset, arrowSize);\n\n    return {\n      popperStyles: {\n        ...popperStyles,\n        ['--radix-popper-transform-origin' as any]: transformOrigin,\n      },\n      arrowStyles,\n      placedSide: side,\n      placedAlign: align,\n    };\n  }\n\n  // create a new rect as if element had been moved to new placement\n  const popperRect = DOMRect.fromRect({ ...popperSize, ...popperPoint });\n\n  // create a new rect representing the collision boundaries but taking into account any added tolerance\n  const collisionBoundariesRectWithTolerance = getContractedRect(\n    collisionBoundariesRect,\n    collisionTolerance\n  );\n\n  // check for any collisions in new placement\n  const popperCollisions = getCollisions(popperRect, collisionBoundariesRectWithTolerance);\n\n  // do all the same calculations for the opposite side\n  // this is because we need to check for potential collisions if we were to swap side\n  const oppositeSide = getOppositeSide(side);\n  const oppositeSidePopperPoint = allPlacementPoints[oppositeSide][align];\n  const updatedOppositeSidePopperPoint = DOMRect.fromRect({\n    ...popperSize,\n    ...oppositeSidePopperPoint,\n  });\n  const oppositeSidePopperCollisions = getCollisions(\n    updatedOppositeSidePopperPoint,\n    collisionBoundariesRectWithTolerance\n  );\n\n  // adjust side accounting for collisions / opposite side collisions\n  const placedSide = getSideAccountingForCollisions(\n    side,\n    popperCollisions,\n    oppositeSidePopperCollisions\n  );\n\n  // adjust alignnment accounting for collisions\n  const placedAlign = getAlignAccountingForCollisions(\n    popperSize,\n    anchorRect,\n    side,\n    align,\n    popperCollisions\n  );\n\n  const placedPopperPoint = allPlacementPoints[placedSide][placedAlign];\n\n  // compute adjusted popper / arrow styles\n  const popperStyles = getPlacementStylesForPoint(placedPopperPoint);\n\n  let arrowStyles = UNMEASURED_ARROW_STYLES;\n  if (arrowSize) {\n    arrowStyles = getPopperArrowStyles({\n      popperSize,\n      arrowSize,\n      arrowOffset,\n      side: placedSide,\n      align: placedAlign,\n    });\n  }\n\n  const transformOrigin = getTransformOrigin(\n    popperSize,\n    placedSide,\n    placedAlign,\n    arrowOffset,\n    arrowSize\n  );\n\n  return {\n    popperStyles: {\n      ...popperStyles,\n      ['--radix-popper-transform-origin' as any]: transformOrigin,\n    },\n    arrowStyles,\n    placedSide,\n    placedAlign,\n  };\n}\n\ntype AllPlacementPoints = Record<Side, Record<Align, Point>>;\n\nfunction getAllPlacementPoints(\n  popperSize: Size,\n  anchorRect: ClientRect,\n  sideOffset: number = 0,\n  alignOffset: number = 0,\n  arrowSize?: Size\n): AllPlacementPoints {\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n\n  const x = getPopperSlotsForAxis(anchorRect, popperSize, 'x');\n  const y = getPopperSlotsForAxis(anchorRect, popperSize, 'y');\n\n  const topY    = y.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const bottomY = y.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n  const leftX   = x.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const rightX  = x.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n\n  // prettier-ignore\n  const map: AllPlacementPoints = {\n    top: {\n      start:  { x: x.start + alignOffset, y: topY },\n      center: { x: x.center,              y: topY },\n      end:    { x: x.end - alignOffset,   y: topY },\n    },\n    right: {\n      start:  { x: rightX, y: y.start + alignOffset },\n      center: { x: rightX, y: y.center },\n      end:    { x: rightX, y: y.end - alignOffset },\n    },\n    bottom: {\n      start:  { x: x.start + alignOffset, y: bottomY },\n      center: { x: x.center,              y: bottomY },\n      end:    { x: x.end - alignOffset,   y: bottomY },\n    },\n    left: {\n      start:  { x: leftX, y: y.start + alignOffset },\n      center: { x: leftX, y: y.center },\n      end:    { x: leftX, y: y.end - alignOffset },\n    },\n  };\n\n  return map;\n}\n\nfunction getPopperSlotsForAxis(anchorRect: ClientRect, popperSize: Size, axis: Axis) {\n  const startSide = axis === 'x' ? 'left' : 'top';\n  const anchorStart = anchorRect[startSide];\n\n  const dimension = axis === 'x' ? 'width' : 'height';\n  const anchorDimension = anchorRect[dimension];\n  const popperDimension = popperSize[dimension];\n\n  // prettier-ignore\n  return {\n    before: anchorStart - popperDimension,\n    start:  anchorStart,\n    center: anchorStart + (anchorDimension - popperDimension) / 2,\n    end:    anchorStart + anchorDimension - popperDimension,\n    after:  anchorStart + anchorDimension,\n  };\n}\n\n/**\n * Gets an adjusted side based on collision information\n */\nfunction getSideAccountingForCollisions(\n  /** The side we want to ideally position to */\n  side: Side,\n  /** The collisions for this given side */\n  collisions: Collisions,\n  /** The collisions for the opposite side (if we were to swap side) */\n  oppositeSideCollisions: Collisions\n): Side {\n  const oppositeSide = getOppositeSide(side);\n  // in order to prevent premature jumps\n  // we only swap side if there's enough space to fit on the opposite side\n  return collisions[side] && !oppositeSideCollisions[oppositeSide] ? oppositeSide : side;\n}\n\n/**\n * Gets an adjusted alignment based on collision information\n */\nfunction getAlignAccountingForCollisions(\n  /** The size of the popper to place */\n  popperSize: Size,\n  /** The size of the anchor we are placing around */\n  anchorSize: Size,\n  /** The final side */\n  side: Side,\n  /** The desired align */\n  align: Align,\n  /** The collisions */\n  collisions: Collisions\n): Align {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n  const startBound = isHorizontalSide ? 'left' : 'top';\n  const endBound = isHorizontalSide ? 'right' : 'bottom';\n  const dimension = isHorizontalSide ? 'width' : 'height';\n  const isAnchorBigger = anchorSize[dimension] > popperSize[dimension];\n\n  if (align === 'start' || align === 'center') {\n    if ((collisions[startBound] && isAnchorBigger) || (collisions[endBound] && !isAnchorBigger)) {\n      return 'end';\n    }\n  }\n\n  if (align === 'end' || align === 'center') {\n    if ((collisions[endBound] && isAnchorBigger) || (collisions[startBound] && !isAnchorBigger)) {\n      return 'start';\n    }\n  }\n\n  return align;\n}\n\nfunction getPlacementStylesForPoint(point: Point): CSS.Properties {\n  const x = Math.round(point.x + window.scrollX);\n  const y = Math.round(point.y + window.scrollY);\n  return {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    minWidth: 'max-content',\n    willChange: 'transform',\n    transform: `translate3d(${x}px, ${y}px, 0)`,\n  };\n}\n\nfunction getTransformOrigin(\n  popperSize: Size,\n  side: Side,\n  align: Align,\n  arrowOffset: number,\n  arrowSize?: Size\n): CSS.Properties['transformOrigin'] {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n\n  const arrowBaseLength = arrowSize ? arrowSize.width : 0;\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n  const sideOffset = arrowBaseToTipLength;\n  const alignOffset = arrowBaseLength / 2 + arrowOffset;\n\n  let x = '';\n  let y = '';\n\n  if (isHorizontalSide) {\n    x = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.width - alignOffset}px`,\n    }[align];\n\n    y = side === 'top' ? `${popperSize.height + sideOffset}px` : `${-sideOffset}px`;\n  } else {\n    x = side === 'left' ? `${popperSize.width + sideOffset}px` : `${-sideOffset}px`;\n\n    y = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.height - alignOffset}px`,\n    }[align];\n  }\n\n  return `${x} ${y}`;\n}\n\nconst UNMEASURED_POPPER_STYLES: CSS.Properties = {\n  // position: 'fixed' here is important because it will take the popper\n  // out of the flow so it does not disturb the position of the anchor\n  position: 'fixed',\n  top: 0,\n  left: 0,\n  opacity: 0,\n  pointerEvents: 'none',\n};\n\nconst UNMEASURED_ARROW_STYLES: CSS.Properties = {\n  // given the arrow is nested inside the popper,\n  // make sure that it is out of the flow and doesn't hinder then popper's measurement\n  position: 'absolute',\n  opacity: 0,\n};\n\ntype GetArrowStylesOptions = {\n  /** The size of the popper to place */\n  popperSize: Size;\n  /** The size of the arrow itself */\n  arrowSize: Size;\n  /** An offset for the arrow along the align axis */\n  arrowOffset: number;\n  /** The side where the arrow points to */\n  side: Side;\n  /** The alignment of the arrow along the side */\n  align: Align;\n};\n\n/**\n * Computes the styles necessary to position, rotate and align the arrow correctly.\n * It can adjust itself based on anchor/popper size, side/align and an optional offset.\n */\nfunction getPopperArrowStyles({\n  popperSize,\n  arrowSize,\n  arrowOffset,\n  side,\n  align,\n}: GetArrowStylesOptions): CSS.Properties {\n  const popperCenterX = (popperSize.width - arrowSize.width) / 2;\n  const popperCenterY = (popperSize.height - arrowSize.width) / 2;\n\n  const rotationMap = { top: 0, right: 90, bottom: 180, left: -90 };\n  const rotation = rotationMap[side];\n  const arrowMaxDimension = Math.max(arrowSize.width, arrowSize.height);\n\n  const styles: CSS.Properties = {\n    // we make sure we put the arrow inside a 1:1 ratio container\n    // this is to make the rotation handling simpler\n    // as we do no need to worry about changing the transform-origin\n    width: `${arrowMaxDimension}px`,\n    height: `${arrowMaxDimension}px`,\n\n    // rotate the arrow appropriately\n    transform: `rotate(${rotation}deg)`,\n    willChange: 'transform',\n\n    // position the arrow appropriately\n    position: 'absolute',\n    [side]: '100%',\n\n    // Because the arrow gets rotated (see `transform above`)\n    // and we are putting it inside a 1:1 ratio container\n    // we need to adjust the CSS direction from `ltr` to `rtl`\n    // in some circumstances\n    direction: getArrowCssDirection(side, align),\n  };\n\n  if (side === 'top' || side === 'bottom') {\n    if (align === 'start') {\n      styles.left = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.left = `${popperCenterX}px`;\n    }\n    if (align === 'end') {\n      styles.right = `${arrowOffset}px`;\n    }\n  }\n\n  if (side === 'left' || side === 'right') {\n    if (align === 'start') {\n      styles.top = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.top = `${popperCenterY}px`;\n    }\n    if (align === 'end') {\n      styles.bottom = `${arrowOffset}px`;\n    }\n  }\n\n  return styles;\n}\n\n/**\n * Adjusts the arrow's CSS direction (`ltr` / `rtl`)\n */\nfunction getArrowCssDirection(side: Side, align: Align): CSS.Property.Direction {\n  if ((side === 'top' || side === 'right') && align === 'end') {\n    return 'rtl';\n  }\n\n  if ((side === 'bottom' || side === 'left') && align !== 'end') {\n    return 'rtl';\n  }\n\n  return 'ltr';\n}\n\n/**\n * Gets the opposite side of a given side (ie. top => bottom, left => right, …)\n */\nfunction getOppositeSide(side: Side): Side {\n  const oppositeSides: Record<Side, Side> = {\n    top: 'bottom',\n    right: 'left',\n    bottom: 'top',\n    left: 'right',\n  };\n  return oppositeSides[side];\n}\n\n/**\n * Creates a new rect (`ClientRect`) based on a given one but contracted by\n * a given amout on each side.\n */\nfunction getContractedRect(rect: ClientRect, amount: number) {\n  return DOMRect.fromRect({\n    width: rect.width - amount * 2,\n    height: rect.height - amount * 2,\n    x: rect.left + amount,\n    y: rect.top + amount,\n  });\n}\n\n/**\n * Gets collisions for each side of a rect (top, right, bottom, left)\n */\nfunction getCollisions(\n  /** The rect to test collisions against */\n  rect: ClientRect,\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect: ClientRect\n) {\n  return {\n    top: rect.top < collisionBoundariesRect.top,\n    right: rect.right > collisionBoundariesRect.right,\n    bottom: rect.bottom > collisionBoundariesRect.bottom,\n    left: rect.left < collisionBoundariesRect.left,\n  };\n}\n\ntype Collisions = ReturnType<typeof getCollisions>;\n\nexport { getPlacementData, SIDE_OPTIONS, ALIGN_OPTIONS };\nexport type { Side, Align };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}