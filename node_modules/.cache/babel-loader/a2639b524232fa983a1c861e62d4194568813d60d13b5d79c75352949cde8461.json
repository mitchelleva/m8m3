{"ast":null,"code":"export function observeElementRect(n, o) {\n  const a = e.get(n);\n  return void 0 === a ? (e.set(n, {\n    rect: {},\n    callbacks: [o]\n  }), 1 === e.size && (t = requestAnimationFrame(c))) : a.callbacks.push(o), () => {\n    const c = e.get(n);\n    if (void 0 === c) return;\n    const a = c.callbacks.indexOf(o);\n    a > -1 && c.callbacks.splice(a, 1), 0 === c.callbacks.length && (e.delete(n), 0 === e.size && cancelAnimationFrame(t));\n  };\n}\nlet t;\nconst e = new Map();\nfunction c() {\n  const n = [];\n  e.forEach((t, e) => {\n    const c = e.getBoundingClientRect();\n    var o, a;\n    o = t.rect, a = c, (o.width !== a.width || o.height !== a.height || o.top !== a.top || o.right !== a.right || o.bottom !== a.bottom || o.left !== a.left) && (t.rect = c, n.push(t));\n  }), n.forEach(t => {\n    t.callbacks.forEach(e => e(t.rect));\n  }), t = requestAnimationFrame(c);\n}","map":{"version":3,"names":["observeElementRect","n","o","a","e","get","set","rect","callbacks","size","t","requestAnimationFrame","c","push","indexOf","splice","length","delete","cancelAnimationFrame","Map","forEach","getBoundingClientRect","width","height","top","right","bottom","left"],"sources":["/Users/mitchelleva/projects/me8porty/m8magic/node_modules/@radix-ui/rect/dist/packages/core/rect/src/observeElementRect.ts"],"sourcesContent":["type Measurable = { getBoundingClientRect(): ClientRect };\n\n/**\n * Observes an element's rectangle on screen (getBoundingClientRect)\n * This is useful to track elements on the screen and attach other elements\n * that might be in different layers, etc.\n */\nfunction observeElementRect(\n  /** The element whose rect to observe */\n  elementToObserve: Measurable,\n  /** The callback which will be called when the rect changes */\n  callback: CallbackFn\n) {\n  const observedData = observedElements.get(elementToObserve);\n\n  if (observedData === undefined) {\n    // add the element to the map of observed elements with its first callback\n    // because this is the first time this element is observed\n    observedElements.set(elementToObserve, { rect: {} as ClientRect, callbacks: [callback] });\n\n    if (observedElements.size === 1) {\n      // start the internal loop once at least 1 element is observed\n      rafId = requestAnimationFrame(runLoop);\n    }\n  } else {\n    // only add a callback for this element as it's already observed\n    observedData.callbacks.push(callback);\n  }\n\n  return () => {\n    const observedData = observedElements.get(elementToObserve);\n    if (observedData === undefined) return;\n\n    // start by removing the callback\n    const index = observedData.callbacks.indexOf(callback);\n    if (index > -1) {\n      observedData.callbacks.splice(index, 1);\n    }\n\n    if (observedData.callbacks.length === 0) {\n      // stop observing this element because there are no\n      // callbacks registered for it anymore\n      observedElements.delete(elementToObserve);\n\n      if (observedElements.size === 0) {\n        // stop the internal loop once no elements are observed anymore\n        cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\n// ========================================================================\n// module internals\n\ntype CallbackFn = (rect: ClientRect) => void;\n\ntype ObservedData = {\n  rect: ClientRect;\n  callbacks: Array<CallbackFn>;\n};\n\nlet rafId: number;\nconst observedElements: Map<Measurable, ObservedData> = new Map();\n\nfunction runLoop() {\n  const changedRectsData: Array<ObservedData> = [];\n\n  // process all DOM reads first (getBoundingClientRect)\n  observedElements.forEach((data, element) => {\n    const newRect = element.getBoundingClientRect();\n\n    // gather all the data for elements whose rects have changed\n    if (!rectEquals(data.rect, newRect)) {\n      data.rect = newRect;\n      changedRectsData.push(data);\n    }\n  });\n\n  // group DOM writes here after the DOM reads (getBoundingClientRect)\n  // as DOM writes will most likely happen with the callbacks\n  changedRectsData.forEach((data) => {\n    data.callbacks.forEach((callback) => callback(data.rect));\n  });\n\n  rafId = requestAnimationFrame(runLoop);\n}\n// ========================================================================\n\n/**\n * Returns whether 2 rects are equal in values\n */\nfunction rectEquals(rect1: ClientRect, rect2: ClientRect) {\n  return (\n    rect1.width === rect2.width &&\n    rect1.height === rect2.height &&\n    rect1.top === rect2.top &&\n    rect1.right === rect2.right &&\n    rect1.bottom === rect2.bottom &&\n    rect1.left === rect2.left\n  );\n}\n\nexport { observeElementRect };\nexport type { Measurable };\n"],"mappings":"OAOA,SAASA,mBAEPC,CAAA,EAEAC,CAAA;EAEA,MAAMC,CAAA,GAAeC,CAAA,CAAiBC,GAAA,CAAIJ,CAAA;EAgB1C,YAdqB,MAAjBE,CAAA,IAGFC,CAAA,CAAiBE,GAAA,CAAIL,CAAA,EAAkB;IAAEM,IAAA,EAAM;IAAkBC,SAAA,EAAW,CAACN,CAAA;EAAA,IAE/C,MAA1BE,CAAA,CAAiBK,IAAA,KAEnBC,CAAA,GAAQC,qBAAA,CAAsBC,CAAA,MAIhCT,CAAA,CAAaK,SAAA,CAAUK,IAAA,CAAKX,CAAA,GAGvB;IACL,MAAMU,CAAA,GAAeR,CAAA,CAAiBC,GAAA,CAAIJ,CAAA;IAC1C,SAAqB,MAAjBW,CAAA,EAA4B;IAGhC,MAAMT,CAAA,GAAQS,CAAA,CAAaJ,SAAA,CAAUM,OAAA,CAAQZ,CAAA;IACzCC,CAAA,IAAS,KACXS,CAAA,CAAaJ,SAAA,CAAUO,MAAA,CAAOZ,CAAA,EAAO,IAGD,MAAlCS,CAAA,CAAaJ,SAAA,CAAUQ,MAAA,KAGzBZ,CAAA,CAAiBa,MAAA,CAAOhB,CAAA,GAEM,MAA1BG,CAAA,CAAiBK,IAAA,IAEnBS,oBAAA,CAAqBR,CAAA;EAAA;AAAA;AAgB7B,IAAIA,CAAA;AACJ,MAAMN,CAAA,GAAkD,IAAIe,GAAA;AAE5D,SAASP,EAAA;EACP,MAAMX,CAAA,GAAwC;EAG9CG,CAAA,CAAiBgB,OAAA,CAAQ,CAACV,CAAA,EAAMN,CAAA;IAC9B,MAAMQ,CAAA,GAAUR,CAAA,CAAQiB,qBAAA;IAsB5B,IAAoBnB,CAAA,EAAmBC,CAAA;IAAnBD,CAAA,GAnBAQ,CAAA,CAAKH,IAAA,EAmBcJ,CAAA,GAnBRS,CAAA,GAqB3BV,CAAA,CAAMoB,KAAA,KAAUnB,CAAA,CAAMmB,KAAA,IACtBpB,CAAA,CAAMqB,MAAA,KAAWpB,CAAA,CAAMoB,MAAA,IACvBrB,CAAA,CAAMsB,GAAA,KAAQrB,CAAA,CAAMqB,GAAA,IACpBtB,CAAA,CAAMuB,KAAA,KAAUtB,CAAA,CAAMsB,KAAA,IACtBvB,CAAA,CAAMwB,MAAA,KAAWvB,CAAA,CAAMuB,MAAA,IACvBxB,CAAA,CAAMyB,IAAA,KAASxB,CAAA,CAAMwB,IAAA,MAzBnBjB,CAAA,CAAKH,IAAA,GAAOK,CAAA,EACZX,CAAA,CAAiBY,IAAA,CAAKH,CAAA;EAAA,IAM1BT,CAAA,CAAiBmB,OAAA,CAASV,CAAA;IACxBA,CAAA,CAAKF,SAAA,CAAUY,OAAA,CAAShB,CAAA,IAAaA,CAAA,CAASM,CAAA,CAAKH,IAAA;EAAA,IAGrDG,CAAA,GAAQC,qBAAA,CAAsBC,CAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}